<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯ AI ç…§ç‰‡äº‘æ‰‹åŠ¿äº¤äº’</title>
    <style>
        :root { --gold: #d4af37; --red: #b22222; --green: #1a472a; }
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        
        /* UI å¼•å¯¼å±‚ */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10; padding: 20px; box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 50%, rgba(0,0,0,0.4) 100%);
        }
        .header { text-align: center; color: var(--gold); text-shadow: 0 0 10px rgba(212,175,55,0.8); }
        .footer { display: flex; justify-content: space-between; align-items: flex-end; pointer-events: auto; }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-tag {
            background: rgba(0,0,0,0.6); color: var(--gold); padding: 5px 15px;
            border-radius: 20px; border: 1px solid var(--gold); font-size: 12px;
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            background: var(--red); color: white; border: none; padding: 12px 20px;
            border-radius: 50px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(178,34,34,0.4); transition: transform 0.2s;
        }
        .btn:active { transform: scale(0.9); }

        /* æ‘„åƒå¤´å°çª— */
        #video-wrap {
            width: 100px; height: 75px; border-radius: 8px; border: 1px solid var(--gold);
            overflow: hidden; background: #222; transform: scaleX(-1);
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; }
        
        /* éšè—çš„æ–‡ä»¶è¾“å…¥ */
        #file-input { display: none; }
    </style>
</head>
<body>

<div class="overlay">
    <div class="header">
        <h2 style="margin:0; letter-spacing: 2px;">MAGICAL XMAS</h2>
        <div id="status-tag">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>

    <div class="footer">
        <div>
            <input type="file" id="file-input" accept="image/*" multiple>
            <button class="btn" onclick="document.getElementById('file-input').click()">æŒ‚è½½ç…§ç‰‡</button>
            <p style="color:white; font-size:10px; margin-top:8px; opacity:0.7;">å¼ æ‰‹:æ•£å¼€ | æ¡æ‹³:èšæ‹¢</p>
        </div>
        <div id="video-wrap">
            <video id="input-video" playsinline></video>
        </div>
    </div>
</div>

<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
    const CONFIG = {
        pCount: 500, // ç§»åŠ¨ç«¯å‡é‡ä¿æŒæµç•…
        treeH: 10,
        treeR: 4,
        colors: [0x1a472a, 0xd4af37, 0xb22222]
    };

    let scene, camera, renderer, instMesh, photoGroup;
    let particles = [];
    let state = 'IDLE'; // IDLE, SCATTER
    let handReady = false;

    // --- åˆå§‹åŒ–æ¸²æŸ“å™¨ ---
    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 18);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('container').appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);

        photoGroup = new THREE.Group();
        scene.add(photoGroup);

        createTree();
        setupHands();
        animate();
    }

    // --- åˆ›å»º 3D åœ£è¯æ ‘ç²’å­ ---
    function createTree() {
        const geo = new THREE.IcosahedronGeometry(0.12, 0);
        const mat = new THREE.MeshStandardMaterial({ metalness: 0.7, roughness: 0.2 });
        instMesh = new THREE.InstancedMesh(geo, mat, CONFIG.pCount);
        
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        for (let i = 0; i < CONFIG.pCount; i++) {
            const h = Math.random() * CONFIG.treeH;
            const r = (1 - h / CONFIG.treeH) * CONFIG.treeR;
            const theta = Math.random() * Math.PI * 2;
            
            const targetPos = new THREE.Vector3(
                Math.cos(theta) * r, h - CONFIG.treeH/2, Math.sin(theta) * r
            );
            const scatterPos = new THREE.Vector3(
                (Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30
            );

            particles.push({ current: targetPos.clone(), target: targetPos, scatter: scatterPos });

            dummy.position.copy(targetPos);
            dummy.updateMatrix();
            instMesh.setMatrixAt(i, dummy.matrix);
            instMesh.setColorAt(i, color.setHex(CONFIG.colors[i % 3]));
        }
        scene.add(instMesh);
    }

    // --- ç…§ç‰‡å¤„ç†é€»è¾‘ ---
    document.getElementById('file-input').onchange = (e) => {
        const files = e.target.files;
        for(let file of files){
            const url = URL.createObjectURL(file);
            const tex = new THREE.TextureLoader().load(url);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2), mat);
            
            // åˆå§‹åœ¨æ ‘ä¸Šçš„éšæœºä½ç½®
            const h = Math.random() * CONFIG.treeH;
            const r = (1 - h / CONFIG.treeH) * CONFIG.treeR + 0.5;
            const theta = Math.random() * Math.PI * 2;
            mesh.position.set(Math.cos(theta)*r, h - CONFIG.treeH/2, Math.sin(theta)*r);
            mesh.userData.origin = mesh.position.clone();
            mesh.userData.scatter = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
            
            photoGroup.add(mesh);
        }
    };

    // --- çŠ¶æ€åˆ‡æ¢åŠ¨ç”» ---
    function switchState(newState) {
        if(state === newState) return;
        state = newState;
        document.getElementById('status-tag').innerText = state === 'IDLE' ? 'çŠ¶æ€ï¼šèšæ‹¢' : 'çŠ¶æ€ï¼šæ•£å¼€';

        particles.forEach((p, i) => {
            const dest = state === 'IDLE' ? p.target : p.scatter;
            gsap.to(p.current, { x: dest.x, y: dest.y, z: dest.z, duration: 1.2, ease: "back.out(1.2)" });
        });

        photoGroup.children.forEach(mesh => {
            const dest = state === 'IDLE' ? mesh.userData.origin : mesh.userData.scatter;
            gsap.to(mesh.position, { x: dest.x, y: dest.y, z: dest.z, duration: 1.2 });
        });
    }

    // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
    function setupHands() {
        const video = document.getElementById('input-video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                // ç®€å•çš„æŠ“æ¡ç®—æ³•ï¼šæŒ‡å°–åˆ°æŒå¿ƒçš„è·ç¦»
                const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                if (dist < 0.3) switchState('IDLE');
                else if (dist > 0.5) switchState('SCATTER');
                
                // æ—‹è½¬è·Ÿéš
                gsap.to(scene.rotation, { y: (lm[9].x - 0.5) * 3, x: (lm[9].y - 0.5) * 2, duration: 0.4 });
            }
        });

        const camera = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 480, height: 360
        });
        camera.start();
    }

    function animate() {
        requestAnimationFrame(animate);
        // ç²’å­æ›´æ–°
        const dummy = new THREE.Object3D();
        particles.forEach((p, i) => {
            dummy.position.copy(p.current);
            dummy.updateMatrix();
            instMesh.setMatrixAt(i, dummy.matrix);
        });
        instMesh.instanceMatrix.needsUpdate = true;
        
        // ç…§ç‰‡é¢æœç›¸æœº
        photoGroup.children.forEach(m => m.lookAt(camera.position));
        
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
